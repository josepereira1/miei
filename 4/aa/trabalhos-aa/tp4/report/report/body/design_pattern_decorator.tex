\section{Structural Design Pattern - Decorator}
\label{sec:decorator}

%Não é necessário mais nenhum \hspace
\hspace{3mm} O \textit{Design Pattern} estrutural \textit{Decorator} vem resolver um problema recorrente no desenvolvimento de software, que trata-se da adição de novos comportamentos a objectos, sem necessidade de alterar bastante código, ou aumentar o número de dependências.

Com a finalidade de uma melhor percepção do problema que este design pattern resolve, vai-se seguir um exemplo real referido no website \href{https://refactoring.guru/design-patterns/decorator}{refactoring.guru}. 

Imagine-se um código responsável pela notificação de alguma informação. Deste modo, existirá um cliente e uma classe responsável por essa notificação, sendo neste momento apenas por email. Após o lançamento do produto, verifica-se a necessidade de \textbf{adicionar} novas formas de notificar, tais como: sms, facebook, slack, etc. A primeira solução que poderá ocorrer será utilizar herança, criando subclasses, específicas a cada tipo de notificação, isto é, a classe Email, SMS, Slack, etc..., e estas estenderem a classe responsável pela notificação. No entanto, esta solução contém muitas dependências e um crescimento de subclasses infinito para cada tipo de combinação de notificações, isto é, se se quisesse enviar por exemplo a combinação de SMS + Slack, teria que se criar uma classe específica para tal. Para além destes problemas, muitas linguagens não permitem estender mais do que uma classe, logo utilizar herança será uma má ideia.

Com a finalidade de uma melhor percepção da solução do problema, vai-se usar uma analogia com a realidade. A nível de software a solução para a necessidade de adicionar novas funcionalidades a um objecto, consiste em colocá-lo no "interior"\ de outros, denominados por "\textit{wrappers}".
Em analogia com a realidade, pode-se pensar na boneca \textit{Matriosca}, isto é, a funcionalidade base, consiste na notificação por \textbf{Email}, correspondendo à boneca mais pequena da \textit{Matriosca}. Se for necessário adicionar uma funcionalidade adicional ao \textbf{Email}, por exemplo a notificação por \textbf{SMS}, então vai-se ter uma boneca maior que a do \textbf{Email}, que corresponde ao \textbf{SMS}, e colocar a boneca mais pequena (\textbf{Email}) dentro da boneca do \textbf{SMS}. Ou seja, significa que sempre que se enviar a boneca do \textbf{SMS}, dentro dela vai sempre a boneca do \textbf{Email}, isto é, sempre que se envia o \textbf{SMS}, também se envia o \textbf{Email}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{images/decorator.png}
    \caption{Implementação genérica do design pattern Decorator.}
    \label{fig:decorator}
\end{figure}

Após a analogia apresentada anteriormente, explicar-se-á agora em concreto a implementação do design pattern \textit{Decorator}, seguindo a figura \ref{fig:decorator}. A interface \textbf{Component} representa, tanto o \textbf{componente base}, bem como os seus decoradores ("\textbf{decorators}"). Isto é, existem as classes \textbf{ConcreteComponent} e \textbf{BaseDecorator}, que implementam a interface \textbf{Component}, ou seja, uniformizou-se tanto o componente, como os seus decoradores, facilitando desta forma a criação de camadas (análogo ao  \textit{design pattern} \href{https://refactoring.guru/design-patterns/composite}{\textit{Composite}}), como irá ver-se mais adiante. Tal como foi referido, a classe \textbf{ConcreteComponent}, representa o componente base, ou seja, a funcionalidade base (\textbf{execute()}), que no exemplo apresentado consiste na notificação por \textbf{Email}. A classe \textbf{BaseDecorator}, representa todos os \textbf{decorators}, ou seja, faz o "embrulho" (\textit{wrapped)} do componente, através de composição do mesmo (variável \textbf{wrappee}). A forma como se faz o embrulho ao componente é através do envio do mesmo pelo construtor. Importa realçar a importância de se ter definido a interface \textbf{Component}, pois a mesma é que permite a criação de camadas, uma vez que, a variável que está na classe \textbf{BaseDecorator} é do tipo \textbf{Component}, ou seja, tanto pode ser o componente (\textbf{ConcreteComponent}), como um decorador (\textbf{BaseDecorator}). A razão da existência da classe \textbf{BaseDecorator}, consiste, em que todos os \textbf{decorators}, contenham o componente, e a funcionalidade associada a este, uma vez que, o método \textbf{execute} da classe \textbf{BaseDecorator}, chama o \textbf{execute} do componente, tal como se pode verificar nas notas da figura \ref{fig:decorator}. As classes concretas de cada \textbf{Decorator}, vão estender a superclasse \textbf{BaseDecorator}, herdando o método \textbf{execute()} (\textit{override}), e adicionando a este a nova funcionalidade, com o método \textbf{extra()}. Importa realçar ainda, que cada nova funcionalidade extra que se pretenda, basta criar uma nova classe que estenda a \textbf{BaseDecorator}, redefinindo o método \textbf{execute()}, adicionando-lhe a nova funcionalidade.

Por fim, e não menos importante, o cliente, decide como utilizar os \textbf{componentes} e os respectivos \textbf{decoradores}, ou seja, se o cliente apenas necessitar de enviar notificação por email, apenas cria um \textbf{ConcreteComponent}, isto é, uma única camada. Por outro lado, se o cliente, quiser enviar a notificação por email e SMS, terá que criar o \textbf{ConcreteComponent}, de seguida, o decorador do SMS, \textbf{ConcreteDecoratorSMS}, e no construtor deste enviar o componente. De seguida, através da instância do \textbf{ConcreteDecoratorSMS}, chama o método \textbf{execute()}, criando desta forma, duas camadas. Analisando em concreto, o \textit{flow} deste último exemplo, quando no \textbf{ConcreteDecoratorSMS}, chamar o \textbf{execute()}, este irá executar o \textbf{extra()} (funcionalidade adicional), e chamar o \textbf{execute()} do \textbf{BaseDecorator} (utilizando super.execute()), por sua vez, este irá chamar o \textbf{execute()} do \textbf{Component} (funcionalidade base), criando desta forma, duas camadas.

Assim, para uma melhor percepção do \textit{design pattern}, a equipa implementou o mesmo em relação ao problema apresentado das notificações.

\subsection{Notas em relação ao código do Decorator}
\hspace{3mm} O código do \textit{Decorator} encontra-se no anexo \ref{anexo:decorator}. Nos argumentos, bem como no retorno do método \textbf{execute()}, utilizou-se o tipo \textit{Object}, de forma a facilitar a reutilização da interface \textbf{Component}. 

Na classe \textbf{Client} mostra-se três situações de camadas diferentes, sendo respectivamente exemplos de uma, duas e três camadas. No primeiro exemplo, apenas tem-se o componente base, isto é, aquele que envia a notificação por email. De seguida, temos a adição de uma funcionalidade de notificar o cliente por Slack, ou seja, cria-se um decorador, onde se envia o componente base pelo construtor, criando-se duas camadas. Por fim, é feito um exemplo de três camadas, onde em relação ao caso anterior, cria-se mais um decorador, e envia-se, o decorador anterior como argumento, sendo que o decorador anterior, já trás o componente base "dentro" dele. Assim, através do último decorador, chamando o \textbf{execute()}, vai-se notificar em três camadas, isto é, Email, SMS, Slack. 
